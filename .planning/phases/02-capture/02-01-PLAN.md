---
phase: 02-capture
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/thehook/capture.py
  - tests/test_capture.py
  - tests/fixtures/sample_transcript.jsonl
autonomous: true
requirements: [CAPT-01, CAPT-02]

must_haves:
  truths:
    - "parse_transcript returns a list of message dicts from a valid JSONL file"
    - "User messages with string content are extracted as plain text"
    - "Assistant messages with array-of-blocks content have text blocks joined and tool_use blocks skipped"
    - "read_hook_input reads and returns the JSON payload from stdin"
    - "assemble_transcript_text joins messages with role labels and truncates to max_chars"
  artifacts:
    - path: "src/thehook/capture.py"
      provides: "Transcript parsing functions"
      exports: ["read_hook_input", "parse_transcript", "assemble_transcript_text"]
    - path: "tests/test_capture.py"
      provides: "TDD tests for parsing"
      contains: "test_parse_transcript"
    - path: "tests/fixtures/sample_transcript.jsonl"
      provides: "Minimal JSONL transcript fixture"
      contains: "assistant"
  key_links:
    - from: "src/thehook/capture.py"
      to: "tests/fixtures/sample_transcript.jsonl"
      via: "parse_transcript reads JSONL file"
      pattern: "Path.*read_text.*splitlines"
---

<objective>
Implement JSONL transcript parsing with TDD — the foundational data layer for the capture pipeline.

Purpose: All downstream extraction depends on correctly parsing the two content shapes (string for user, array-of-blocks for assistant) from Claude Code's JSONL transcript format. Getting this wrong causes silent data loss.
Output: Working `parse_transcript`, `read_hook_input`, and `assemble_transcript_text` functions with full test coverage and a reusable JSONL fixture.
</objective>

<execution_context>
@/Users/louisbarbier/.claude/get-shit-done/workflows/execute-plan.md
@/Users/louisbarbier/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-capture/02-RESEARCH.md
@src/thehook/cli.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for transcript parsing and hook input reading</name>
  <files>
    tests/fixtures/sample_transcript.jsonl
    tests/test_capture.py
    src/thehook/capture.py
  </files>
  <action>
1. Create `tests/fixtures/sample_transcript.jsonl` with a minimal transcript containing:
   - Line 1: A "system" type record (should be skipped by parser — not user/assistant)
   - Line 2: A "user" type record with `message.content` as a plain string: "Hello, can you help me set up auth?"
   - Line 3: An "assistant" type record with `message.content` as an array of blocks:
     ```json
     [{"type": "text", "text": "Sure, I can help with authentication."}, {"type": "tool_use", "id": "tu_01", "name": "Read", "input": {"file_path": "/src/auth.py"}}]
     ```
   - Line 4: A second "assistant" type record with multiple text blocks:
     ```json
     [{"type": "text", "text": "Here is the plan:"}, {"type": "text", "text": "Step 1: Create auth module"}]
     ```
   Each line must be a complete JSON object with fields: `type`, `uuid`, `parentUuid`, `sessionId`, `timestamp`, `cwd`, `isSidechain`, `message` (containing `role` and `content`).

2. Create `src/thehook/capture.py` as a skeleton with function signatures and docstrings only — no implementation:
   - `read_hook_input() -> dict` — reads JSON from stdin
   - `parse_transcript(transcript_path: str) -> list[dict]` — parses JSONL into message dicts
   - `assemble_transcript_text(messages: list[dict], max_chars: int = 50_000) -> str` — joins messages with role labels
   Each function body: `raise NotImplementedError`

3. Create `tests/test_capture.py` with these failing tests:
   - `test_read_hook_input_parses_stdin_json` — monkeypatch `sys.stdin` with a StringIO containing `{"session_id": "abc", "transcript_path": "/tmp/t.jsonl"}`, assert returned dict has correct keys
   - `test_parse_transcript_returns_messages` — call `parse_transcript` with the fixture path, assert it returns a list of 3 messages (the system record is skipped)
   - `test_parse_transcript_user_string_content` — assert the first message has `role="user"` and `content="Hello, can you help me set up auth?"`
   - `test_parse_transcript_assistant_block_content` — assert the second message has `role="assistant"` and content is `"Sure, I can help with authentication."` (text block extracted, tool_use skipped)
   - `test_parse_transcript_assistant_multiple_text_blocks` — assert the third message has content `"Here is the plan:\nStep 1: Create auth module"` (two text blocks joined with newline)
   - `test_parse_transcript_nonexistent_file` — assert returns empty list for a path that does not exist
   - `test_parse_transcript_empty_file` — write an empty file via tmp_path, assert returns empty list
   - `test_assemble_transcript_text_formats_messages` — pass 2 messages, assert output contains `[USER]:` and `[ASSISTANT]:` labels
   - `test_assemble_transcript_text_truncates` — pass messages totaling >100 chars with `max_chars=50`, assert output length <= 50 + len of truncation prefix, and starts with `...[truncated]...`

   Use `pytest.fixture` for `sample_transcript_path` that returns `Path(__file__).parent / "fixtures" / "sample_transcript.jsonl"`.

4. Run tests: `pytest tests/test_capture.py -x -v` — ALL must FAIL (NotImplementedError). If any pass, the test is wrong.
  </action>
  <verify>
    <automated>cd /Users/louisbarbier/thehook && pytest tests/test_capture.py -x -v 2>&1 | tail -5</automated>
    <manual>Every test should fail with NotImplementedError — confirms RED phase</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>9 failing tests exist; fixture file created; capture.py has skeleton only</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement transcript parsing to pass all tests</name>
  <files>src/thehook/capture.py</files>
  <action>
Implement the three functions in `src/thehook/capture.py` following the patterns from 02-RESEARCH.md:

1. `read_hook_input() -> dict`:
   - `import sys, json`
   - Read all of stdin with `sys.stdin.read()`
   - Parse with `json.loads(raw)` and return the dict
   - On `json.JSONDecodeError` or empty input, return empty dict `{}`

2. `parse_transcript(transcript_path: str) -> list[dict]`:
   - Follow Pattern 2 from research exactly
   - Use `Path(transcript_path)`, check `.exists()`, return empty list if not
   - Iterate lines with `.read_text().splitlines()`, skip empty lines
   - `json.loads(line)` each line, skip on JSONDecodeError
   - Only process records where `type` is `"user"` or `"assistant"`
   - Extract `role` from `msg.get("role", record_type)`
   - Branch on content type: `isinstance(raw_content, str)` -> use directly; `isinstance(raw_content, list)` -> extract text blocks only (skip tool_use, tool_result, etc. — only include blocks with `type == "text"`); else empty string
   - Append dict with keys: `role`, `content`, `uuid`, `timestamp`

3. `assemble_transcript_text(messages: list[dict], max_chars: int = 50_000) -> str`:
   - Follow Pattern from research: join as `[{ROLE}]: {content}` with `\n\n` separator
   - Skip messages with empty content after strip
   - If `len(full) > max_chars`, truncate to last `max_chars` characters prefixed with `"...[truncated]...\n\n"`

Add module-level constants at the top:
- `MAX_TRANSCRIPT_CHARS = 50_000`

Run `pytest tests/test_capture.py -x -v` — ALL 9 tests must PASS.
  </action>
  <verify>
    <automated>cd /Users/louisbarbier/thehook && pytest tests/test_capture.py -x -v</automated>
    <manual>All 9 tests green; no regressions in existing test suite</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>All 9 parsing tests pass; parse_transcript correctly handles both content shapes; full test suite green</done>
</task>

</tasks>

<verification>
- `pytest tests/test_capture.py -v` — all 9 tests pass
- `pytest tests/ -x -q` — full suite (14 existing + 9 new = 23) passes with no regressions
- `python -c "from thehook.capture import parse_transcript, read_hook_input, assemble_transcript_text"` — imports succeed
</verification>

<success_criteria>
- parse_transcript correctly parses the JSONL fixture into 3 messages
- User string content and assistant array-of-blocks content both handled
- tool_use blocks are skipped, only text blocks extracted
- Truncation works when transcript exceeds max_chars
- read_hook_input reads JSON from stdin
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture/02-01-SUMMARY.md`
</output>

---
phase: 02-capture
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/thehook/capture.py
  - tests/test_capture.py
autonomous: true
requirements: [CAPT-03, CAPT-05]

must_haves:
  truths:
    - "run_claude_extraction calls claude -p with the extraction prompt and returns stdout text on success"
    - "When claude -p exceeds 85 seconds, the entire process group is killed via os.killpg and None is returned"
    - "After killpg, proc.communicate() is called to reap the zombie process"
    - "write_session_file writes a markdown file with YAML frontmatter (session_id, timestamp, transcript_path)"
    - "write_stub_summary writes a stub file with all four sections and failure metadata when extraction fails"
    - "On empty stdout from claude -p (exit 0 but no output), a stub is written instead of an empty file"
  artifacts:
    - path: "src/thehook/capture.py"
      provides: "Extraction and session file writing functions"
      exports: ["run_claude_extraction", "write_session_file", "write_stub_summary"]
    - path: "tests/test_capture.py"
      provides: "TDD tests for extraction and degradation"
      contains: "test_run_claude_extraction"
  key_links:
    - from: "src/thehook/capture.py::run_claude_extraction"
      to: "subprocess.Popen"
      via: "start_new_session=True for process group isolation"
      pattern: "start_new_session=True"
    - from: "src/thehook/capture.py::run_claude_extraction"
      to: "os.killpg"
      via: "TimeoutExpired handler kills process group"
      pattern: "killpg.*SIGKILL"
---

<objective>
Implement LLM extraction subprocess management and graceful degradation with TDD — the reliability layer of the capture pipeline.

Purpose: The extraction call to `claude -p` is the riskiest part of the pipeline: it can hang indefinitely, return empty output, or crash. This plan ensures every failure path writes a stub summary instead of silently failing. The subprocess pattern (Popen + killpg on process group) is critical to prevent zombie processes.
Output: Working `run_claude_extraction`, `write_session_file`, and `write_stub_summary` functions with mocked subprocess tests covering success, timeout, failure, and empty output paths.
</objective>

<execution_context>
@/Users/louisbarbier/.claude/get-shit-done/workflows/execute-plan.md
@/Users/louisbarbier/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-capture/02-RESEARCH.md
@.planning/phases/02-capture/02-01-SUMMARY.md
@src/thehook/capture.py
@tests/test_capture.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RED — Write failing tests for extraction subprocess and session file writing</name>
  <files>tests/test_capture.py</files>
  <action>
Add the following failing tests to `tests/test_capture.py` (below existing parse tests). Import `write_session_file`, `write_stub_summary`, `run_claude_extraction` from `thehook.capture`. These functions do not exist yet so imports will be added at the top.

**Session file writing tests (no mocking needed):**

1. `test_write_session_file_creates_markdown_with_frontmatter(tmp_project)`:
   - Call `write_session_file(tmp_project / "sessions", "sess123", "/tmp/t.jsonl", "## SUMMARY\nTest content")`
   - Assert returned path exists and is a `.md` file
   - Read file content, assert it contains `session_id: sess123`, `transcript_path: /tmp/t.jsonl`, `---` (frontmatter delimiters), and `## SUMMARY`

2. `test_write_session_file_creates_sessions_dir(tmp_project)`:
   - Call with `tmp_project / "nonexistent" / "sessions"` (does not exist yet)
   - Assert directory was created and file was written

3. `test_write_stub_summary_contains_metadata(tmp_project)`:
   - Call `write_stub_summary(tmp_project / "sessions", "sess456", "/tmp/t.jsonl", 42, reason="timeout")`
   - Read the written file, assert it contains `session_id: sess456`, `Extraction timeout`, `42 messages`, and all four section headers (SUMMARY, CONVENTIONS, DECISIONS, GOTCHAS)

4. `test_write_stub_summary_on_failure_reason(tmp_project)`:
   - Call with `reason="error"`, assert file contains `Extraction error`

**Extraction subprocess tests (mocked):**

5. `test_run_claude_extraction_returns_stdout_on_success(monkeypatch)`:
   - Mock `subprocess.Popen` to return a mock proc where:
     - `communicate(timeout=85)` returns `(b"## SUMMARY\nExtracted text", b"")`
     - `returncode` = 0
     - `pid` = 12345
   - Assert `run_claude_extraction("test prompt")` returns `"## SUMMARY\nExtracted text"`

6. `test_run_claude_extraction_returns_none_on_timeout(monkeypatch)`:
   - Mock `subprocess.Popen` to return a mock proc where:
     - `communicate(timeout=85)` raises `subprocess.TimeoutExpired(cmd="claude", timeout=85)`
     - `pid` = 12345
   - Mock `os.getpgid` to return `12345`
   - Mock `os.killpg` to do nothing (assert it was called with `(12345, signal.SIGKILL)`)
   - Add a second `communicate()` call mock (for zombie reap) returning `(b"", b"")`
   - Assert result is `None`
   - Assert `os.killpg` was called exactly once

7. `test_run_claude_extraction_returns_none_on_nonzero_exit(monkeypatch)`:
   - Mock proc with `returncode=1`, `communicate` returns `(b"error output", b"stderr")`
   - Assert result is `None`

8. `test_run_claude_extraction_returns_none_on_empty_stdout(monkeypatch)`:
   - Mock proc with `returncode=0`, `communicate` returns `(b"", b"")`
   - Assert result is `None` (not empty string — falsy check)

9. `test_run_claude_extraction_returns_none_on_oserror(monkeypatch)`:
   - Mock `subprocess.Popen` to raise `FileNotFoundError`
   - Assert result is `None`

Run tests: `pytest tests/test_capture.py -x -v -k "write_session or write_stub or run_claude"` — ALL must FAIL (ImportError or NotImplementedError).
  </action>
  <verify>
    <automated>cd /Users/louisbarbier/thehook && pytest tests/test_capture.py -v -k "write_session or write_stub or run_claude" 2>&1 | tail -5</automated>
    <manual>All 9 new tests fail; existing 9 parse tests still pass</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>9 new failing tests for extraction and file writing; existing parse tests unaffected</done>
</task>

<task type="auto">
  <name>Task 2: GREEN — Implement extraction subprocess and session file writing</name>
  <files>src/thehook/capture.py</files>
  <action>
Add the following functions to `src/thehook/capture.py` (below existing parse functions), following patterns from 02-RESEARCH.md exactly:

1. Add imports at top of file (merge with existing):
   ```python
   import os
   import signal
   import subprocess
   from datetime import datetime, timezone
   ```

2. Add constant: `EXTRACTION_TIMEOUT_SECONDS = 85`

3. `run_claude_extraction(prompt: str) -> str | None`:
   - Follow Pattern 3 from research exactly
   - `subprocess.Popen(["claude", "-p", prompt, "--tools", ""], stdout=PIPE, stderr=PIPE, start_new_session=True)`
   - `proc.communicate(timeout=EXTRACTION_TIMEOUT_SECONDS)`
   - On success (returncode 0): return `stdout.decode("utf-8", errors="replace").strip() or None` — the `or None` handles empty stdout
   - On `TimeoutExpired`: `os.killpg(os.getpgid(proc.pid), signal.SIGKILL)`, then `proc.communicate()` to reap, return None
   - On `OSError` / `FileNotFoundError`: return None

4. `write_session_file(sessions_dir: Path, session_id: str, transcript_path: str, content: str) -> Path`:
   - Follow Pattern 5 from research
   - Generate ISO 8601 timestamp with `datetime.now(timezone.utc).isoformat()`
   - Filename: `{timestamp[:10]}-{session_id[:8]}.md`
   - Write YAML frontmatter (session_id, timestamp, transcript_path) + content
   - `sessions_dir.mkdir(parents=True, exist_ok=True)` before writing
   - Return the output path

5. `write_stub_summary(sessions_dir: Path, session_id: str, transcript_path: str, message_count: int, reason: str = "timeout") -> Path`:
   - Build stub content with all four sections (SUMMARY with reason+count, CONVENTIONS/DECISIONS/GOTCHAS with "None this session.")
   - Call `write_session_file` to write it
   - Return the output path

Run `pytest tests/test_capture.py -x -v` — ALL 18 tests must PASS (9 parse + 9 new).
  </action>
  <verify>
    <automated>cd /Users/louisbarbier/thehook && pytest tests/test_capture.py -x -v</automated>
    <manual>All 18 tests green; full suite passes</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>All 18 tests pass; extraction handles success/timeout/failure/empty; session files have proper frontmatter; stubs written on degradation</done>
</task>

</tasks>

<verification>
- `pytest tests/test_capture.py -v` — all 18 tests pass (9 parse + 9 extraction/file)
- `pytest tests/ -x -q` — full suite passes with no regressions
- `python -c "from thehook.capture import run_claude_extraction, write_session_file, write_stub_summary"` — imports succeed
</verification>

<success_criteria>
- run_claude_extraction returns stdout on success, None on timeout/failure/empty
- TimeoutExpired triggers killpg on process group + zombie reap
- write_session_file creates markdown with YAML frontmatter
- write_stub_summary writes all four sections with failure metadata
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture/02-02-SUMMARY.md`
</output>

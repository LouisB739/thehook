---
phase: 01-setup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/thehook/__init__.py
  - src/thehook/cli.py
  - src/thehook/config.py
  - tests/__init__.py
  - tests/conftest.py
  - tests/test_config.py
autonomous: true
requirements:
  - SETUP-03
  - SETUP-04

must_haves:
  truths:
    - "Running `pip install -e '.[dev]'` produces a working `thehook` CLI command"
    - "Calling `load_config()` with no thehook.yaml returns all default values unchanged"
    - "A partial thehook.yaml overrides only specified keys; unspecified keys retain defaults"
    - "A full thehook.yaml replaces all values with user-specified ones"
  artifacts:
    - path: "pyproject.toml"
      provides: "Package definition with entry point and dependencies"
      contains: "thehook = \"thehook.cli:main\""
    - path: "src/thehook/__init__.py"
      provides: "Package version string"
      contains: "__version__"
    - path: "src/thehook/cli.py"
      provides: "Click group entry point"
      contains: "@click.group"
    - path: "src/thehook/config.py"
      provides: "Config loading with deep-merge and defaults"
      exports: ["load_config", "DEFAULT_CONFIG"]
    - path: "tests/test_config.py"
      provides: "Config system test coverage"
      min_lines: 40
  key_links:
    - from: "pyproject.toml"
      to: "src/thehook/cli.py"
      via: "[project.scripts] entry point"
      pattern: "thehook.*thehook\\.cli:main"
    - from: "src/thehook/config.py"
      to: "thehook.yaml"
      via: "load_config reads YAML from project root"
      pattern: "project_dir.*thehook\\.yaml"
---

<objective>
Create the installable Python package scaffold and implement the configuration system with sensible defaults.

Purpose: Establishes the foundation that all other Phase 1 work depends on — a working `thehook` CLI command and a config module that loads `thehook.yaml` or falls back to defaults.
Output: Installable package (`pip install -e .`), Click CLI skeleton, config module with tests passing.
</objective>

<execution_context>
@/Users/louisbarbier/.claude/get-shit-done/workflows/execute-plan.md
@/Users/louisbarbier/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-setup/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create package scaffold and test infrastructure</name>
  <files>
    pyproject.toml
    src/thehook/__init__.py
    src/thehook/cli.py
    tests/__init__.py
    tests/conftest.py
  </files>
  <action>
Create the full Python package scaffold:

1. `pyproject.toml` — Use hatchling build backend. Declare:
   - `name = "thehook"`, `version = "0.1.0"`, `requires-python = ">=3.11"`
   - `dependencies = ["click>=8.1", "pyyaml>=6.0"]`
   - `[project.scripts] thehook = "thehook.cli:main"`
   - `[project.optional-dependencies] dev = ["pytest>=8.0"]`
   - `[tool.hatch.build.targets.wheel] packages = ["src/thehook"]`
   - `[tool.pytest.ini_options] testpaths = ["tests"]` and `pythonpath = ["src"]`

2. `src/thehook/__init__.py` — Contains only `__version__ = "0.1.0"`

3. `src/thehook/cli.py` — Click group skeleton:
   ```python
   import click

   @click.group()
   @click.version_option()
   def main():
       """TheHook - Self-improving long-term memory for AI coding agents."""
       pass
   ```
   No subcommands yet — Plan 02 wires `init`.

4. `tests/__init__.py` — Empty file.

5. `tests/conftest.py` — Shared fixture:
   ```python
   import pytest
   from pathlib import Path

   @pytest.fixture
   def tmp_project(tmp_path):
       """A temporary project directory for testing."""
       return tmp_path
   ```

6. Create virtualenv and install package in dev mode:
   ```bash
   python3 -m venv .venv
   .venv/bin/pip install -e ".[dev]"
   ```

7. Verify the `thehook` command is available:
   ```bash
   .venv/bin/thehook --version
   ```
  </action>
  <verify>
    <automated>.venv/bin/thehook --version</automated>
    <manual>Command prints version string without error</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - `thehook --version` prints "version 0.1.0"
    - `thehook --help` shows the group help text
    - Package installs without errors in editable mode
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config system with TDD</name>
  <files>
    tests/test_config.py
    src/thehook/config.py
  </files>
  <action>
**RED phase — write tests first in `tests/test_config.py`:**

Test cases to write (use `tmp_project` fixture from conftest):

1. `test_load_config_no_yaml_returns_defaults` — No `thehook.yaml` exists; `load_config(tmp_project)` returns dict with `token_budget=2000`, `consolidation_threshold=5`, `active_hooks=["SessionEnd", "SessionStart"]`.

2. `test_load_config_full_yaml_overrides_all` — Write `thehook.yaml` to `tmp_project` with all three keys set to custom values; `load_config(tmp_project)` returns the custom values.

3. `test_load_config_partial_yaml_merges_with_defaults` — Write `thehook.yaml` with only `token_budget: 3000`; assert `token_budget=3000` but `consolidation_threshold=5` and `active_hooks` unchanged.

4. `test_load_config_empty_yaml_returns_defaults` — Write an empty `thehook.yaml`; `load_config(tmp_project)` returns defaults (handles `yaml.safe_load` returning `None`).

5. `test_load_config_does_not_mutate_defaults` — Call `load_config` twice with different configs; second call returns fresh defaults, not mutated state from first call.

Run tests — they MUST all fail (module not found).

**GREEN phase — implement `src/thehook/config.py`:**

```python
from pathlib import Path
from copy import deepcopy
import yaml

DEFAULT_CONFIG = {
    "token_budget": 2000,
    "consolidation_threshold": 5,
    "active_hooks": ["SessionEnd", "SessionStart"],
}

def _deep_merge(base: dict, override: dict) -> dict:
    result = deepcopy(base)
    for key, value in override.items():
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = _deep_merge(result[key], value)
        else:
            result[key] = deepcopy(value)
    return result

def load_config(project_dir: Path) -> dict:
    config_path = project_dir / "thehook.yaml"
    if not config_path.exists():
        return deepcopy(DEFAULT_CONFIG)
    with open(config_path) as f:
        user_config = yaml.safe_load(f) or {}
    return _deep_merge(DEFAULT_CONFIG, user_config)
```

Run tests — they MUST all pass.

**CRITICAL:** Config file path is `project_dir / "thehook.yaml"` (project ROOT, NOT `.thehook/config.yaml`). This matches SETUP-03 requirements.
  </action>
  <verify>
    <automated>.venv/bin/pytest tests/test_config.py -x -v</automated>
    <manual>All 5 config tests pass; no test modifies DEFAULT_CONFIG</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>
    - All 5 config tests pass
    - `load_config()` with no YAML returns exact defaults (SETUP-04)
    - Partial YAML merges correctly with defaults preserved (SETUP-03)
    - DEFAULT_CONFIG is never mutated between calls
  </done>
</task>

</tasks>

<verification>
1. `thehook --version` prints version without error
2. `thehook --help` shows group description
3. `pytest tests/test_config.py -x -v` — all 5 tests pass
4. `pytest tests/ -x -q` — full suite green
</verification>

<success_criteria>
- Package installs in editable mode and `thehook` command is available
- Config system loads `thehook.yaml` from project root when present (SETUP-03)
- Config system returns sensible defaults when no YAML file exists (SETUP-04)
- All tests pass with `pytest tests/ -x -q`
</success_criteria>

<output>
After completion, create `.planning/phases/01-setup/01-01-SUMMARY.md`
</output>
